%% Based on the style files for ACL-2015

\documentclass[english,main=russian,11pt]{article}
\usepackage[hidelinks]{hyperref}
\usepackage{acl2015}
\usepackage[numbers]{natbib}
\usepackage{fancyhdr}
\usepackage{amsmath,amsthm,amssymb}
\usepackage{mathtext}
\usepackage[T1,T2A,OT1]{fontenc} 
\usepackage[russian,english]{babel}
\usepackage[utf8]{inputenc}

\title{The Keep Network:\protect\\A Privacy Layer for Public Blockchains}

\author{Matt Luongo \\
  {\tt mhluongo@gmail.com} \\\And
  Corbin Pon \\
  {\tt corbin.pon@gmail.com} \\}

\date{}

\pagestyle{fancy}
\fancyhf{}
\renewcommand{\headrulewidth}{0pt}

\lfoot{Draft: \href{https://github.com/keep-network/whitepaper/tree/COMMIT}{COMMIT} - \today}

\usepackage{abstract}
\renewcommand{\abstractname}{Резюме}

\begin{document}

\thispagestyle{fancy}

\maketitle

\begin{abstract}

  Мы представляем кeep, базовый элемент конфиденциальности 
  для разработки смарт-контрактов в паблик блокчейнах, который 
  позволяет безопасное хранение и использование секретной 
  информации, а вместе с этим и вспомогательную  инфраструктуру, 
  в том числе и токены keep.

  Наш последовательный подход к инфраструктуре конфиденциальности 
  может быть представлен на рынке через публичную сеть Ethereum, 
  а также добавлен и адaптирован к использованию в других 
  паблик блокчейнах и кросс-блокчейнах.

\end{abstract}

\section{Мотивация}

\subsection{Ирония паблик блокчейнов}

Паблик блокчейны привнесли беспрецедентную прозрачность и 
аудитоспособность в сферу финансовых технологий. 
Записи неизменяемы, верифицируемы и защищены от цензуры.

К сожалению, эти плюсы являются и минусами для многих потенциальных 
пользователей. 

Каждый  случай финансового использования паблик блокчейна ограничен 
его публичным статусом. Bitcoin позиционировался как более 
конфиденциальный способ оплаты, чем традиционная финансовая система, 
но те, кто знаком с технологией, знают, что, несмотря на то, что 
он защищён от цензуры, он не может быть конфиденциальным по 
определению \cite{bitcoinPrivacy}. Разработчики при знакомстве с 
Ethereum вскоре снижают планку своих ожиданий \cite{ethereumStackexchange}— 
все состояния контракта публикуются в блокчейне и могут быть легко 
прочитаны конкурирующими сторонами.

Эти проблемы признаны разработчиками проектов Bitcoin и Ethereum.

Конфиденциальные транзакции \cite{confidentialTransactions}-текущая 
попытка решения проблемы конфиденциальности, а с ней и 
взаимозаменяемости, в Биткойне, с помощью сайдчейнов \cite{confidentialTransactionsElements}. 
Проект Zerocash \cite{zerocash} применил "доказательства нулевого 
знания" (zero-knowledge proofs) в Биткоине, что привело к созданию 
Zcash \cite{zcash}- криптовалюты, использующей zk-SNARKs для 
обеспечения конфиденциальности транзакций.

Уже в декабре 2014 г., Виталик Бутерин, один из создателей Ethereum, 
исследовал решение этой проблемы при помощи протокола безопасного 
многостороннего вычисления (sMPC) \cite{secretSharingDaos}. Во многих 
недавних публикациях, Бутерин отмечает, что когда он и другие ведут 
переговоры с компаниями о создании приложений на блокчейн, то 
всегда всплывают две основные проблемы - масштабируемость и 
конфиденциальность. \cite{privacyOnTheBlockchain}.

Масштабируемость публичных блокчейнов является препятствием для 
их широкой адаптации. Одни из лучших умов в области криптовалюты \cite{lightning}
\cite{ethereumSharding} \cite{plasma} работают над улучшениями 
в этом направлении. Однако, конфиденциальность не получила должного
внимания, особенно в отношении смарт-контрактов.

Даже базовые виды использования смарт-контрактов, включая 
публикацию секретной информации после соблюдения определённых 
критериев, оценку риска при выдаче кредита, и подпись сообщений 
и транзакций, на сегодняшний день невероятно сложно реализовать в 
паблик блокчейнах.

\subsection{Существующие подходы}

На практике, разработчиками были найдены несколько способов для
разработки децентрализованных приложений, использующих приватные 
данные.

\subsubsection{Шаблон хэш-вскрытия}

Распространенный подход, используемый на публичных блокчейнах - 
это хранение личных данных у пользователей приложения. 
Контракты могут получать доступ и управлять хешами пользовательских 
данных, \cite{commitmentScheme},в то время как оригиналы хранятся 
у пользователя до тех пор, пока не будут раскрыты офф-чейн. 
Мы называем это шаблоном хэш-вскрытия (Hash-reveal pattern).

Для многих приложений такой подход удовлетворителен. Он дает явное 
преимущество в конфиденциальности по отношению к обычным 
веб-приложениям так как ни одна централизованная база данных 
сторонних разработчиков здесь не подвергается риску. Распределенное 
хранение между несколькими пользователями означает, 
что цель для атаки будет рассеяна.

Однако, у этого подхода есть и существенные недостатки. Шаблон 
хэш-вскрытия требует, чтобы все пользователи, участвующие в 
транзакции, были онлайн, осуществляли мониторинг системы, предоставляли 
конфиденциальные данные в случае необходимости, и сверяли хэши с 
приватной информацией, предоставленной другими пользователями.

Данные требования делают шаблон хэш-вскрытия недостаточно гибким для 
сложных протоколов, и так же неподходящим для систем, в которых 
участвуют неодушевлённые  стороны, как, например, децентрализованные 
автономные организации (DAO).

\subsubsection{Приватные блокчейны}

Еще одним видом решения проблемы конфиденциальности, в основном 
используемый финансовой индустрией, является создание приватных 
блокчейнов или так называемых ”закрытых реестров”.

Эти системы работают  в доверенном  или полудоверенном  режиме. Вместо 
того, чтобы использовать proof-of-work или другой механизм консенсуса, 
разработанный с учетом конкурентности в сети, они могут использовать 
системы наподобие RAFT, чтобы достичь согласованности.

Одной из таких систем является система J.P. Morgan Quorum \cite{quorum}- 
форк Ethereum, поддерживающий поддерживающий приватность не только 
смарт-контрактов, но и обмена сообщениями в сети. Другой системой 
является недавно анонсированная Майкрософт система Coco Framework \cite{coco}, 
обеспечивающая конфиденциальность данных поверх существующего 
приватного блокчейна.

Эти системы решают проблемы конфиденциальности, увы, за счет утраты 
многих преимуществ публичного блокчейна - публичной подотчетности,
общедоступности и защищенности от цензуры.

\subsubsection{Доказательства с нулевым разглашением (Zero-knowledge proofs)}

Одним из самых известных примеров использования zero-knowledge proofs 
для поддержания конфиденциальности на публичных блокчейнах является Zcash \cite{zcash} 

Zero-knowledge proofs позволяют одной доказывающей стороне (рrover), 
убедить в достоверности утверждения другую проверяющую сторону 
(verifier), без выявления содержания информации, использованной для 
доказательства утверждения. Например, доказывающий мог бы показать,
что он обладает доступом к приватному ключу путем зашифровки сообщения, 
выбранного проверяющим. Доказательство может быть легко 
проверено проверяющим при помощи расшифровки сообщения, используя 
паблик ключ. Приватный ключ остается при этом нерассекреченым.

Что касается сферы владения, zero-knowledge proofs могут быть 
использованы какой-либо из сторон для доказательства того, что 
у них есть доступ к средствам, или, в случае Zcash, одной из сторон 
для доказательства майнерам, что транзакция действительна, в соответствии 
с правилами консенсуса сети.

Zero-knowledge proofs могут быть использованы для создания частных 
финансовых систем в паблик блокчейнах. Однако сами по себе они не 
дают возможности безопасно передавать личные данные от одной стороны к 
другой и, опять же, требуют всегда находиться онлайн для хэш-вскрытия.

Доказательства с нулевым разглашением - очень мощный криптографический 
инструмент который может быть использован в сочетании с другими 
методами для безопасного предоставления доступа к приватным данным 
и вычислениям \ref{sMPC}

\subsection{Публичное использование, конфиденциальные данные}

Ни один из этих методов не предоставляет удовлетворительного  решения
для построения публично верифицируемого, децентрализованного, 
устойчивого к цензуре приложения, которое будет работать с 
конфиденциальной информацией.

К примеру, данные решения не могут обеспечить разработку контракта, 
раскрывающего конфиденциальные данные в случае возникновения 
разногласий между двумя сторонами, или подписание сообщения, 
верифицирующего контракт офф-чейн (вне основной цепи) или безопасное
шифрование файлов \footnote{Мы рассмотрим темы приложений подробнее 
в разделе \ref{applications}}.

\section{Представляем хранилища keep}

Чтобы решить эту проблему несоответствия между прозрачностью публичных 
блокчейнов и потребностью множества автономных смарт-контрактов в 
конфиденциальных данных, мы представляем вашему вниманию {\em keep}.

Keep - это офф-чейн контейнер для конфиденциальных данных. Keep 
позволяет контрактам управлять и использовать конфиденциальные данные 
без раскрытия этих данных в паблик блокчейне.

\subsection{Операции с хранилищами keep}

\begin{table*}[t]
  \centering
  \begin{tabular}{|rp{10cm}|}
  \hline
  \multicolumn{2}{|c|}{\textit{Keep operations}} \\
  \textbf{Create:} & $Contract_{owner}$ публикует запрос на создание, 
  кладя начальный депозит и паблик ключ, $K_{Contract_{owner}}$.\\
  \textbf{Accept:} & Хранилище, $Keep_{accepted}$, публикует один 
  или более паблик ключей $K_{Keep_{accepted_i}}$ говоря тем самым 
  о своей готовности.\\
  \textbf{Populate:} & $Contract_{owner}$ публикует изначальную 
  секретную информацию он-чейн, зашифрованную полностью или по частям 
  одним или более $K_{Keep_{accepted_i}}$, или же публикует какие-либо 
  особые требования для генерирования.\\
  \textbf{Grant:} & $Contract_{owner}$ публикует ещё один адрес 
  контракта, $Contract_{delegate}$, и уровень допуска - 
  $P_{read}$ or $P_{admin}$.\\
  \textbf{Compute:} & $Contract_{owner}$ или $Contract_{delegate}$
  публикует функцию, которую нужно вычислить над секретной информацией, 
  $F(S,...)$, а так же другие параметры $F$. Изначально, $F {\in}
  \{f_{identity},f_{rsa},f_{ecdsa}\}$, но дополнительные параметры 
  планируются в дальнейшей pаботе.\\
  \textbf{Results:} & $Keep_{accepted}$ публикует результат 
  вычисления - либо цельно, либо в несколько этапов.\\
  \textbf{Shutdown:} & $Contract_{owner}$ или $Contract_{delegate}$
  с допуском $P_{admin}$ публикует запрос на закрытие хранилища.\\
  \hline
\end{tabular}
\end{table*}

Хотя контейнеры keep хранят информацию офф-чейн, их поддержка и 
взаимодействие с контрактами происходит он-чейн. Ниже мы опишем 
эти он-чейн операции с хранилищами Keep. Практическое применение 
Keep, включая гарантии безопасности, описано в разделах \ref{eliminatingRisk} 
and \ref{keepProviders}.

\subsubsection{Создание и заполнение}

Контракт, $Contract_{owner}$, запрашивает хранилище keep, публикуя запрос 
в блокчейн. Когда хранилище приняло запрос, $Keep_{accepted}$, и завершило 
инициализацию офф-чейн, оно отвечает на данный запрос набором открытых 
ключей, которые запрашивающий контракт может использовать, чтобы 
конфиденциально связываться с хранилищем. 

 Как только хранилище создано, оно может быть заполнено различными способами. 
 Децентрализованные приложения (dApps) могут размещать зашифрованные при 
 помощи паблик ключей кеер конфиденциальные данные на блокчейне, или 
 отправлять данные хранилищу кеер офф-чейн. А так же, keep может 
 само-заполниться псевдослучайными данными.

\subsubsection{Публикация данных он-чейн}

Назначением хранилища keep является вычисление функции на 
основании секретных данных и её публикация на блокчейне.

Сначала хранилища будут поддерживать публикацию секретных 
данных он-чейн либо неизменными, либо зашифрованными при 
помощи публичного ключа, предоставленного владельцем контракта
$Contract_{owner}$. Благодаря этому становится возможной 
функциональность, которой сложно достигнуть в нынешних 
публичных смарт-контрактах, как, например, раскрывающий 
конфиденциальные данные Dead Man's Switch, полезный в различных 
схемах децентрализованного рынка.

Хранилища кеер могут использовать секретные данные множеством 
других способов, включая их использование в качестве основы 
для создания ключа для симметричного шифрования и подписи.

\subsubsection{Управление доступом}

Контракт, владеющий хранилищем кеер $Contract_{owner}$ также 
может предоставлять доступ к хранилищу и другим контрактам.

Может предоставляться доступ для чтения или администрирования, 
позволяя другому контракту i($Contract_{delegate}$) запрашивать 
публикацию содержимого хранилища (read permission, $P_{read}$), 
или предоставлять дальнейший доступ другим контрактам (admin permission, $P_{admin}$). 
Владельцы ($Contract_{owner}$) также могут отзывать собственный доступ. 

Управление доступом дает возможность многосторонней безопасной 
передачи средств на хранение третьему лицу, а также проверки 
и контроля секретного доступа.

\subsubsection{Продолжительность использования}

В зависимости от варианта использования, хранилища keep могут 
быть использованы в течении короткого или длительного периода.
Контракты могут запрашивать закрытие хранилища, а также  должны 
разрешать коллизии с хранилищами, которые неожиданно завершили 
работу (сценарии, которые более подробно описаны в разделе \ref{uptime}.

\section{Устранение риска с третьих сторон} \label{eliminatingRisk}

Мы описали обычный черный ящик для хранения данных офф-чейн. 
Стандартизация этого метода управления секретной информацией 
позволит секретной информации быть купленной, проданной, отправленной 
в публичный блокчейн, но, по сути, не решает проблемы стороннего риска.

Далее мы опишем технику устранения стороннего риска.

\subsection{Безопасное многостороннее вычисление} \label{sMPC}

Безопасное многостороннее вычисление (sMPC) - это тип криптографической 
системы, где вычисление распределяется между многими участниками, 
некоторые из которых могут иметь недобросовестные намерения. Заказчиком 
каждому из участников изначально даётся доступ к части секретной 
информации, над которой он вычисляет функцию. Результаты сообщаются 
заказчику, который может собрать результат воедино. Таким образом, 
никто из участников не будет обладать большей информацией, чем была 
получена ими изначально.

Наглядно sMPC работает следующим образом:

\begin{enumerate}
  \item Заказчик $D$ хочет вычислить функцию $F$ над секретной информацией,
      $S$.
  \item Заказчик выбирает $n$ - ное количество сторон для вычисления, 
  и отправляет каждой часть секретной информации, $s_i$.
  \item Каждая сторона вычисляет функцию через их часть $f_i(s_i)$ и 
  сообщает результат заказчику.
  \item Заказчик соединяет выходы данных так, что
      $G(f_1(s_1),f_2(s_2),...f_n(s_n)) = F(S)$
\end{enumerate}

Части $s_i$ должны быть выбраны таким способом, чтобы разоблачение 
одной части не поставило под угрозу разоблачение секретной 
информации $S$. Распространенным подходом является использование 
схемы распределения секрета Шамира (Shamir's Secret Sharing) \cite{shamir}, 
где детали секрета остаются нераскрытыми перед $n-1$ нечестных сторон. 

Это объяснение справедливо для всех $F$ включая сложение, вычитание 
и умножение на известную константу. Однако, для достижения общих 
вычислений, нам также необходимо надежно умножать секретные данные. 

Умножение привносит то, что в литературе называют «раундами» — общение 
между сторонами, а не только c заказчиком $D$.

Чтобы умножить два секрета, каждая сторона $P_i$ выбранных заказчиком $n$ 
разбивает свою часть информации, $s_i$, на два компонента, $s_{i1}$ и
$s_{i2}$. Сторона умножает эти два компонента, получая в результате
$s_{i'}$. Каждая $P_i$ здесь действует как заказчик среди оставшихся 
сторон, разбивая $s_{i'}$ на $n-1$ частей. 

Каждая $P_i$ теперь может решить свою полученную в раунде умножения 
часть информации, $s'_i$, имея допуск к $n-1$ частям $s_{i'}$.

Благодаря сложению и умножению, sMPC могут надежно и безопасно выполнять 
основные вычисления, но за счёт избыточного взаимодействия между 
вычисляющими сторонами.

\subsection{sMPC и блокчейн}

Первоначально sMPC был разработан в 1982 году \cite{yao1982protocols}, 
но его практическое применение было лимитировано из-за ограничений на 
модель безопасности. Существующие решения sMPC обеспечивают безопасность 
только в случае честности большинства участников. 

Появление блокчейна позволяет надёжно использовать sMPC и при 
неблагоприятных сценариях. Используя блокчейн как не подлежащий 
изменениям реестр, sMPC становится надёжным инструментом даже в случае 
недобросовестности большинства участников \cite{spdz}, а также 
сверх-устойчивым к Sybil-атакам, благодаря требованию токена сети 
(см. раздел \ref{incentivizingProviders}).

По этим причинам блокчейны и sMPC естественным образом сочетаются друг 
с другом. В пространстве смарт-контрактов, sMPC был уже предложен ранее 
как механизм конфиденциальности. 

В 2014 году, Виталик Бутерин дал введение в этот предмет в своей ранней 
статье о конфиденциальности в паблик блокчейне Ethereum \cite{secretSharingDaos}. 
В 2016 году команда из UMD разработала систему HAWK \cite{hawk}, которая 
объединяет публичные и конфиденциальные смарт-контракты с помощью sMPC, 
а также проект Enigma \cite{enigma}, разработанный Массачусетским 
Техническим Институтом, описывает похожую на нашу систему, с более широким 
уклоном на общие конфиденциальные вычисления.

Keep network соединяет эти идеи в первую готовую к использованию систему 
sMPC для паблик блокчейнов.

\section{Провайдеры Keep} \label{keepProviders}

Сеть Keep включает различные виды провайдеров, каждый из которых имеет 
как сильные стороны, так и недостатки. Однако, самым важным провайдером 
является инновационное применение  sMPC.

\subsection{Простой sMPC}

За простым sMPC хранилищем кeep стоит $n$ - ное количество нод, каждая 
из которых отвечает за часть секретной информации, и эта информация 
не может быть восстановлена без вовлечения всех  $n$ нод.

Эти хранилища могут быть безопасно заполнены путём разделения 
секретной информации на части, используя схему разделения секрета 
Шамира \cite{shamir}, и шифруя каждую часть, используя публичный ключ 
соответствующей ноды. Затем, зашифрованные части могут быть опубликованы 
в паблик блокчейне или можно с ними связываться офф-чейн. 

Единственное вычисление, которые эти хранилища будут проводить — это 
распределенный RSA на sMPC, используемый для публикации зашифрованных 
данных в блокчейн.

\subsection{Подписывающие sMPC}

Следующий провайдер внесёт в sMPC хранилище кеер две новые операции — 
безопасное генерирование псевдослучайных чисел, и подпись и шифрование
данных, используя содержимое хранилища keep в качестве ключа.

В дополнение к простым псевдослучайным числам, подписывающие хранилища 
кеер смогут генерировать пары ключей RSA \cite{mauland2009realizing} 
и Bitcoin \cite{gennaro2016threshold,coinparty}, или заполняться 
ими через схему распределения секретной информации.

Это означает, что подписывающиеся хранилища кеер смогут подписывать и
обеспечивать безопасную передачу контрактов он-чейн и офф-чейн, и так 
же подписывать транзакции Bitcoin, Ethereum и других криптовалют.

И, наконец, подписывающие хранилища keep смогут действовать как pRNG 
оракулы, значительно улучшая тем самым существующие методы генерации 
случайных чисел на паблик блокчейнах.

\subsection{Будущие провайдеры}

Офф-чейн шаблон keep достаточно гибок, чтобы включить в себя различные 
виды других подсоединяемых провайдеров, и каждый имеет свои уникальные 
плюсы. 

\subsubsection{Безопасное аппаратное обеспечение}

Кеер, поддерживаемые безопасным аппаратным обеспечением, могут быть 
использованы для уменьшения стоимости обеспечения безопасности 
конфиденциальных данных путем проверки того, что для привилегированных 
данных используется только подписанный код.

Вместо требования безопасного разделения секрета между n - ным 
количеством нод, секретная информация может быть отправлена одной ноде, 
которая должным образом ответила на вызов, доказав, что исполняет 
подписанный код. В таком случае требуется меньшее количество нод, a 
так же эти хранилища не будут страдать от вычислительных издержек sMPC 
из-за наложения коммуникации между вычисляющими сторонами.
  
Такой вид безопасности существенно слабее, чем тот, что предоставляет sMPC. 
Если один безопасный производитель аппаратного обеспечения взломан, он 
ставит все ноды, использующие это оборудование, под угрозу, смещая модель 
угрозы. Стоимость и преимущества этого подхода будут зависеть от вида его 
использования.

\subsubsection{Частные смарт-контракты}

В отличии от похожих работ над такими системами, как Enigma \cite{enigma} 
или Hawk \cite{hawk}, которые используют sMPC для построения 
вычислительных сетей на основе офф-чейн технологии или технологии 
альтернативных чейн для частных смарт-контрактов, мы решили ограничить 
функции первоначальных sMPC хранилищ keep до обеспечения безопасности, 
генерирования, хранения, шифровки и передачи секретной информации. Такие 
ограничения помогают свести к минимуму количество уязвимых мест для атаки 
на хранилище в рабочей сети.

В дальнейшей работе, схемы sMPC могут быть использованы для создания 
хранилищ кеер с более расширенными функциями. Такие хранилища сделают 
возможными более сложные варианты использования, как например, 
управление приватными реестрами через публичные блокчейны или 
бездоверительное исполнение кода третьей стороны над приватными данными.


\section{Экономическое мотивировсание провайдеров} \label{incentivizingProviders}

Провайдеры должны быть экономически мотивированы, чтобы обеспечить 
высокую производительность сети. Управление хранилищами и обеспечение 
их безопасности должно быть выгодно, учитывая использование избыточных 
вычислительных ресурсов и ресурсов хранения.  

 В то же время, контрактам потребителя нужны кеер, предоставляющие следующие
 условия:

\begin{itemize}
  \item Высокую доступность
  \item Устойчивость к потере данных
  \item Обеспечение конфиденциальности
  \item Целостность (верность) данных
\end{itemize}

\subsection{Плата за хранилища}

Оптимальная структура оплаты для провайдеров keep будет вознаграждать 
широкодоступные хранилища и наказывать хранилища с низкой 
производительностью.

<sequence diagram of deposit + per-operation payment>

Двумя основными затратами для провайдера являются хранение и вычисление, 
что привело к логичному решению: хранилища кеер берут оплату за каждый 
блок и за операцию.

Плата за блок может осуществляться путем внесения депозита в управляющий 
контракт во время инициализации кеер, периодически измеряема в течении 
срока хранения и повторно пополняема по мере необходимости запрашивающим 
смарт-контрактом. Несмотря на то, что это кажется отличной возможностью 
для использования платежных каналов, сведя к минимуму он-чейн комиссии, 
методы обеспечения безопасности здесь отличаются от типичных двухсторонних 
каналов. Эти различия обсуждаются подробнее в следующем разделе.

Оплата за операцию осуществляется проще. В каждом запросе о публикации 
содержимого кeep потребуется оплата суммы, согласованной при инициализации 
хранилища.

\subsection{Опасения насчёт процесса непрерывной работы и надежности} \label{uptime}

Поскольку постоянная доступность критически необходима для практического 
использования хранилищ keep, внезапно прерванная работа должна быть 
экономически наказуема.

<proper shutdown protocol>

Работа любого хранилища кеер, которое не отвечает должным образом в 
течении определенного количества блоков, будет прервана. Прерванные 
keep будут лишены всех депозитов клиентов, которые еще не выплачены. 
Чтобы избежать искажения баланса клиентов, депозиты, которые были 
заработаны, но еще не выплачены, сгорают, а незаработанные депозиты 
будут возвращены клиенту.

Для провайдера кеер, волатильность на криптовалютных рынках может стать 
сильным мотивирующим фактором прервать работу хранилища. Если стоимость 
уплаченной валюты значительно снижается по сравнению с затратами на 
управление хранилищем, в интересах провайдера становится выделять свои 
ограниченные ресурсы на обслуживание клиентов, которые готовы заплатить 
больше.

Чтобы противостоять этой проблеме, провайдерам кеер потребуется протокол 
для выборочного пересмотра платы за обслуживание активного хранилища.

\subsection{Опасения относительно активных атак}
\label{activeAttacks}

Существующие фреймворки sMPC с открытым исходным кодом, такие как 
VIFF \cite{viff}, являются надёжными в случае активных атак только 
при условии, что большинство нод добросовестны.
В таких атаках, хранилища могут быть вынуждены выдать неверно 
сформулированные данные, но секретная информация может быть 
скомпрометирована только в случае если все ноды, имеющие свою долю 
секретной информации, поддерживающие sMPC хранилища сговорятся, 
что крайне маловероятно. Следовательно, это делает атаки Sybil 
практически невозможными.

Недавние решения с использованием доказательств SPDZ доказательств \cite{spdz} 
закрепленных в блокчейне \cite{bitcoinSmpc, blockchainMultipartyComputation} 
елают подобные атаки невозможными, даже если все вовлеченные ноды 
keep скомпрометированы. Хранилища sMPC будут публиковать в паблик 
блокчейн доказательства, которые могут быть использованы для 
подтверждения истинности. Угроза активных атак в таком случае 
сводится только лишь к нарушению доступности хранилищ в сети, 
а не к выдаче неверных данных.

Мы решаем проблему разрывa соединения в сети, внедряя два 
экономических стимула для  провайдеров, делая активные 
атаки на доступность данных дорогостоящими, и, тем самым, 
непрактичными.

Итак, первый стимул -  провайдеры должны будут доказать 
наличие денежного запаса в валюте токена системы. Значительное 
нарушение сети приведёт к снижению стоимости токена, и это 
стимулирует провайдеров вести себя честно, иначе их собственные 
запасы обесценятся. Эта схема также обеспечивает устойчивость 
к атакам Sybil, т.к. атакующему нужно будет сначала приобрести 
часть токенов, превышающую ту, что заморожена провайдерами кеер, 
чтобы обеспечить себе приоритет выбора для поддержки новых 
хранилищ. 

Во-вторых, избыток хранилищ может быть использован во благо 
дальнейшей минимизации сбоев доступности сети \cite{blockchainMultipartyComputation}. 
Все ноды могут быть обязаны внести депозит при публикации 
результатов. Если подлинность их результатов не может быть 
доказана с помощью включённого в процесс SPDZ, они лишаются 
депозита  и он распределяется между конкурирующими нодами.

\section{Общее описание дизайна сети}

Установка системы конфиденциальности на основе sMPC в 
паблик блокчейне нуждается в вспомогательной инфраструктуре. 
Чтобы создать функционирующую приватную сеть на основе Ethereum-
блокчейна, на который пал наш первый выбор, мы добавим в него 
компоненты для обеспечения справедливого выбора нод хранилищ, 
отчетности по результатам работы и экономического стимулирования 
участников сети.

\subsection{Токен сети Кеер}

Для участия провайдерам потребуется собственный токен сети, 
 \textit{KEEP}

Чтобы быть выбранным для предоставления ноды для нового хранилища, 
провайдер должен заморозить минимальное требуемое системой 
количество токенов KEEP, с помощью совместного стэйкинг контракта.

В любое время провайдер может принять решение извлечь свою долю- 
обналичить, к примеру. Но такие решения будут подвергнуты 
двухнедельному периоду ожидания, чтобы исключить вариант снятия 
баланса провайдерами сразу после стейкинга, т.к. это может 
оказать неблагоприятное воздействие на ход работы и справедливое 
распределение выбора хранилищ.

Требование использования собственного токена сети вместо валюты 
используемого блокчейна означает, что провайдеры будут испытывать 
на себе негативные эффекты внешних факторов в случае 
недобросовестного поведения (см. раздел \ref{activeAttacks}). 
Это также поможет сделать сеть гораздо более устойчивой к 
Sybil-атакам (см. раздел \ref{fairKeepSelection}).

\subsection{Обеспечение справедливого распределения выбора хранилищ}
\label{fairKeepSelection}

Контракты, запрашивающие хранилища, и провайдеры, должны 
быть корректно соединены. В идеале, система позволила бы 
устанавливать цены, стимулируя новых провайдеров разных типов 
хранилищ к присоединению, если загруженность невелика.

Эта проблема соединения хранилищ и провайдеров прекрасно подходит 
для рынка. К сожалению, он-чейн рынки представляют собой сложную 
проблему. Они комплексны, подвержены атакам майнеров 
(miner frontrunning), и манипуляциям с ценами и заказами. 
  
Умный атакующий может манипулировать рынком, несправедливо отдавая 
преимущество быть выбранным определенному хранилищу. Рынок, на 
котором заявки подают и покупатели и продавцы, будет подвергать 
сеть Sybil-атакам.
  
Вместо рынка нам нужен справедливый механизм распределения выбора 
хранилища.

\subsubsection{Случайные маячки}

Лучший способ выбора провайдера для нового хранилища —  случайность. 
К сожалению, Ethereum поддерживает только детерминированные функции. 
Контракты, нуждающиеся в случайном числе, часто полагаются на услуги 
доверенного оракула.

Система децентрализована настолько, насколько централизован её 
наибольший компонент. Опираться на доверенную третью сторону - 
это неприемлемый риск для основной функции проекта.
  
Вместо этого мы можем использовать наших провайдеров как 
децентрализованный источник энтропии. Все провайдеры, заперевшие 
свой депозит для стейкинга, могут учавствовать в процессе 
генерации случайных чисел.
  
Для дизайна такой системы существует несколько условий:

\begin{itemize}
\item Провайдеры не должны иметь никаких преимуществ перед друг 
другом в процессе выбора ноды.
\item Для каждого блока в паблик блокчейне будет необходимо 
хотя бы одно случайное число достаточного размера.
На сегодняшний день время блока Ethereum составляет 25 секунд, 
но этот показатель, скорее всего, значительно изменится в будущем. 
Процесс генерации случайных чисел (RNG) должен быть достаточно 
быстрым, чтобы при необходимости поддерживать гораздо более 
короткое время блока. \item RNG должен быть устойчивым к сбоям 
в нодах, т.к. тогда новые хранилища не могут быть созданы. 
Поэтому желательна устойчивость к обрывам соединений между 
провайдерами, а также к активным DoS-атакам.
\item Хоть это и не обязательное усовершенствование, но добавление 
в сеть Ethereum механизма генерации случайных чисел также поможет 
многим другим проектам.
\end{itemize}

Большинство распределенных схем генерации ключей слишком медленны 
или склонны к манипуляциям, которые необходимо учитывать. Любая 
выбранная нами схема должна работать безотказно, независимо от 
количества участвующих провайдеров. Но на самом деле большинство 
таких схем требуют неоднократного общения участников между собой, 
замедляя тем самым процесс генерации ключей и оставляя высокую 
вероятность сбоя связи. 
 
К счастью, команда Dfinity решила эти проблемы с помощью своего 
проекта случайных маяков, основанного на концепции, которую они 
называют пороговый переключатель \cite{thresholdRelay}.

\subsubsection{Пороговый переключатель (Threshold relay)}

\begin{table*}[t]
  \centering
  \begin{tabular}{|rp{10cm}|}
  \hline
  \multicolumn{2}{|c|}{\textit{Повторяющие пороговые подписи для случайности 
  в существующих чейн.}} \\
  \textbf{Регистрация:} & Когда провайдеры присоединяются к сети, они 
  регистрируются по крайней мере в одной пороговой группе $G_i$ из всех 
  групп $G$, генерируя часть приватного ключа группы, $s_i$. Количество 
  участников в пороговых группах не превышает $c$,  и может пересекаться. 
  Группы, достигшие этого максимального числа участников, публикуют свой 
  паблик ключ на блокчейн. Назовём их $G_{registered}$. \\
  \textbf{Доверительная установка:} & Доверенный участник сети публикует 
  случайную единицу $r_0$ в блокчейн в качестве первого результата маяка. \\
  \textbf{Запуск:} & $mod(r_{0}, |G_{registered}|)$ используется 
  для выбора зарегистрированной пороговой группы, $G_i$, из всех
  $G_{registered}$. $G_i$ подписывает $r_0$ и публикует результат,
  $r_1 = threshold(r_0, s_{0\rightarrow{t}})$ , где $s_{0\rightarrow{t}}$ - 
  - минимальное количество необходимых частей, чтобы группа могла создать 
  подпись. Необходимо учесть, что $threshold(...)$ должна быть 
  детерминистичной схемой подписи, во избежание возможности  
  манипуляции подписями заинтересованными в этом лицами. \\
  \textbf{Итерация:} & Каждый блок, опубликованный на чейн, будет 
  включать в себя подпись из $G_{registered}$ cлучайной единицы $r_i$. 
  По мере роста чейна, подписывающие пороговые группы будут изменятся, 
  основываясь на доступности провайдера.    
  Если какая-либо группа не отвечает в течение времени $t$, группа 
  удаляется из $G_{registered}$. \\
  \textbf{Сбои:} & При каждой итерации может случиться, что группа 
  не может сгенерировать подпись по причине сбоя. Если группа $G_i$ 
  не может подписать случайную 
  единицу последней итерации, вместо неё будет использовано $G_{i+1}$. \\
  \hline
\end{tabular}
\end{table*}

Эта работа опирается на идею о пороговых схемах обмена секретной 
информацией - схемах, которые сохраняют конфиденциальность до 
некоторого соблюдённого количества(порога) $t$ добросовестных 
участников.

Пороговые подписи (threshold signatures) — это похожая идея. 
Пороговая подпись — это подпись, раздробленная между $n$ -ным 
количеством участников, требующая некоторой минимальной $t$ активных 
участников для подписи. Эта идея похожа на «multi-sig», которая 
сегодня используется для криптовалют.

Однако традиционный multi-sig требует наличие смарт-контракта на 
блокчейне для проверки каждой подписи и вывода средств. А схемы 
пороговых подписей нуждаются в пороге $t$ чтобы в принципе создать 
подпись, что убирает излишний уровень сложности и координации 
между сторонами. 

Использование пороговых подписей означает, что некоторые из участников 
группы подписания могут быть недоступны, но, несмотря на это, подпись 
будет успешно сформирована, имея необходимое количество $t$ 
функционирующих подписывающих участников. Это обеспечивает наш маяк 
некоторым необходимым процентом устойчивости при сбоях или 
недобросовестном поведении нод.

Если концепт пороговых подписей вам кажется знакомым, то это потому, 
что это является одной из основных функций хранилищ. Например, кеер 
осуществляет подпись биткоин транзакции, используя пороговый ECDSA.  

Пороговый переключатель — это способ объединения пороговых подписей 
для создания случайного маяка. Участники порогового переключателя 
формируют пороговые группы. Эти группы генерируют новые паблик ключи, 
которые идентифицируют группу и связаны с новым созданным пороговым 
приватным ключом(private key), разделенным между участниками.

Когда провайдеры присоединятся к сети, они образуют пороговые 
группы(threshold groups). Затем, эти группы подписывают некую часть 
случайных данных, заранее предоставленных ранними участниками сети, 
для запуска переключателя. Полученная подпись предоставит случайные 
данные для следующей итерации, которая будет проверена остальными 
участниками сети и, в случае неверности, отклонена. Каждую итерацию, 
новая группа подписи выбирается с помощью случайного значения, 
полученного в предыдущей итерации. По ходу подписания всеми группами 
значения предыдущей итерации, если какая-либо выбранная подпись 
неверна, то вместо нее может быть выбрана подпись из следующей группы
в очереди. 

Важно отметить, что схема пороговой подписи должна быть 
детерминистической, чтобы избежать возможности манипуляции подписями 
заинтересованными лицами. В похожих работах использовались 
подписи BLS \cite{BLS} 
  
\subsubsection{Группа выбора Keep}

Наша система порогового переключателя будет состоять из провайдеров 
хранилищ, которые ожидают возможности быть выбранными для поддержки 
нового хранилища, собирая комиссию с работы данного хранилища.

Каждый блок будет включать в себя случайную подпись, опубликованную 
назначенной группой выбора хранилищ. Для хранилищ, которым потребуются 
новые ноды, провайдеры будут выбраны случайным образом, используя 
значение маяка из последнего блока. 
  
Таким образом, мы можем обеспечить равные шансы всем провайдерам, 
сделавшим стэйкинг, при этом удерживая атаки Sybil очень дорогими.

\section{The result registry}

Keep предложит ряд способов публикаций результатов в паблик блокчейн. 
В случае, когда хранилища keep публикуют в смарт-контракте, 
предоставленном владельцем keep, координация проста. В тех случаях, 
когда нет прямой связи со смарт-контрактом, по умолчанию будет 
предоставлен реестр результатов, чтобы упростить координацию между 
владельцем и хранилищем.

\section{Применения}
\label{applications}

\subsection{Dead man switch}

A dead man switch — это устройство, которое автоматически активируется, 
если его владелец становится недееспособным. Хранилища предоставляют 
определенный тип dead man switch- публикацию секретной информации под 
определенными условиями, прописанными в контракте. 

Примеры приложений, использующих dead man switch с помощью 
хранилищ keep, включают автоматическое унаследование («отправьте 
выбранному мной получателю мой приватный ключ, в случае, если я 
перестану проверять данные ежеквартально»), арбитраж с временными 
ограничениями («если решение не принято в 10 блоках, опубликовать 
секретную информацию»), а также защиту для лиц, принимающих участие 
(«опубликуйте ключ к этим страховым файлам, если я не отмечался в 
системе»).

\subsection{Торговые площадки для цифровых товаров}

Сегодня покупка и продажа цифровых товаров в паблик блокчейнах 
требует размещения оффчейн. Keep значительно упрощают создание 
торговых площадок для цифровых товаров, таких как аудио- и видеофайлы.

Без хранилищ keep, каждая передача частных цифровых товаров требует 
одной или более конструкций по раскрытию хэша он-чейн. Для более 
сложных сценариев, требующих депонирования, арбитров и других сторон, 
которым может понадобиться доступ к пересылаемому цифровому товару, 
будут необходимы ${n^2}$ он-чейн транзакции, для обеспечения должной 
безопасности. А так же от каждой стороны требуется находиться онлайн 
для участия в сделке.  Хранилища keep снимают требованиe всегда 
находиться онлайн и упрощают протокол хэш-раскрытия для доступа к 
управлению. Доступ к хранилищу проверяем, и участники могут иметь к 
нему доступ, без возможности просматривания его содержимого, что 
позволяет продолжать оптимизацию. 

Устраняя требование всегда находиться онлайн, или сложных протоколов 
раскрытия информации, keep может эффективно поддерживать такие сервисы, 
как iTunes на блокчейне.

\subsection{Псевдослучайный оракул}

Поскольку хранилища могут заполняться случайными данными, они могут 
действовать как псевдослучайные оракулы, улучшая популярные в настоящее 
время подходы \cite{prngStackexchange}. sMPC и другие надёжные 
хранилища кеер хорошо подходят для децентрализованных лотерей и других 
подобных игр, где нужна случайность, а также представляют собой 
фундамент для других он-чейн алгоритмов, где требуется надёжный pRNG. 

Эта особенность - важный компонент более сложных использований кеер, 
таких как, например, децентрализованное подписание.

\subsection{Сервис децентрализованного подписания}

Подписывающие провайдеры sMPC хранилищ могут подписывать сообщения, 
в том числе блокчейн транзакции, используя сгенерированный или 
предоставленный приватный ключ.

Впервые контракты смогут идентифицировать себя оффчейн, не требуя 
от получателя принимать во внимание состояние блокчейна.
  
Рассмотрим сервис децентрализованного подписания для биткоин 
транзакции. Такой сервис может участвовать в мультиподписных 
транзакциях, подписывая только те транзакции, которые следуют 
строгим правилам, включая дневные лимиты расходов и белые списки 
получателей. 
  
Другие виды использования такого сервиса включают двухфакторную 
аутентификацию, когда контракт может отвечать на протокол запроса 
на основе правил блокчейна.

\subsection{Кастоидальные кошельки и кросс-чейн торговля}

В качестве особого варианта использования сервиса подписи, контракты 
могут использовать хранилища для создания собственных кошельков с 
криптовалютами, полностью контролируя любые полученные средства. 

Например, контракт может генерировать Bitcoin-кошелек и подписывать 
Bitcoin транзакции в ответ на получение средств на собственный 
блокчейн контракта.

\subsection{Сервис шифрования для блокчейн хранилища}

Такие службы, как Filecoin \cite{filecoin} и Storj \cite{storj} 
создаются для обеспечения дешевого, повсеместного хранения, 
доступного в глобальном масштабе, посредством умных контрактов
(smart contracts) и традиционных интерфейсов хранения. 

Эти службы предоставляют несколько гарантий конфиденциальности по 
умолчанию, оставляя шифрование файлов ответственностью самого 
пользователя. Keeр хранилища предоставят конфиденциальный мост к 
блокчейн хранилищу. Генерируя ключ AES при инициализации хранилища 
keep и обеспечивая хранилищу офф-чейн доступ к данным, умные 
контракты могут использовать хранилища keep для защиты файлов, 
хранящихся на децентрализованных сервисах.

\subsection{Банковские операции на публичных блокчейнах}

По мере того, как увеличивается количество провайдеров кеер, 
больше приложений, для проектирования которых ранее требовались 
приватные блокчейны, теперь могут быть разработаны в публичных 
сетях.

Множество примеров можно найти среди традиционных финансовых 
решений. Например, кредитование - базовая услуга, предоставляемая 
большинством банков.

Процесс кредитования включает в себя необходимость предоставления 
ряда конфиденциальной информации в ходе процесса. Кредитные баллы 
заемщика являются конфиденциальной информацией; оценка риска 
является высококонкурентной информацией; условия займа обычно 
не публикуются. 

Провайдеры keep, приводящие в исполнение общие приватные 
смарт-контракты, могут защитить информацию о кредитных баллах 
и процессах оценки рисков, сохраняя при этом аудитоспособность 
и иные преимущества паблик блокчейна.

\bibliographystyle{unsrt}
\bibliography{references}{}

\end{document}
