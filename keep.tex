%% Based on the style files for ACL-2015

\documentclass[11pt]{article}
\usepackage[hidelinks]{hyperref}
\usepackage{acl2015}
\usepackage[numbers]{natbib}

\title{The Keep Network:\protect\\A Privacy Layer for Public Blockchains}

\author{Matt Luongo \\
  {\tt mhluongo@gmail.com}}

\date{}

\begin{document} \maketitle \begin{abstract}

  We introduce the keep, a new privacy primitive for developing smart
  contracts on public blockchains, enabling secure storage and usage
  of secrets, as well as supporting infrastructure, including the keep
  market and token.

  Our incremental approach to privacy infrastructure can be brought
  to market on the Ethereum public network, iterated on, and adapted
  for other public blockchains and cross-blockchain use.

\end{abstract}

\section{Motivation}

\subsection{The irony of public blockchains}

Public blockchains have brought unprecedented transparency and
auditability to financial technology. Records are immutable,
verifiable, and censorship-resistant.

Unfortunately, these strengths are also weaknesses for many potential
users.

For every financial use case a public blockchain enables, its public
status restricts another. Bitcoin is touted as a more private payment
method than the traditional financial system, but those familiar with
the technology know that while it may be censorship-resistant, it's
certainly not private by default \cite{bitcoinPrivacy}. Developers
introduced to Ethereum quickly learn to adjust their expectations
\cite{ethereumStackexchange}- all contract state is published to the
blockchain, and can be easily read by competing interests.

These issues are recognized by developers of the Bitcoin and Ethereum
projects.

Confidential transactions \cite{confidentialTransactions} is an
ongoing effort to bring better privacy, and therefore fungibility, to
Bitcoin via sidechains \cite{confidentialTransactionsElements}. The
Zerocash project \cite{zerocash} applied zero-knowledge proofs to
Bitcoin, leading to the creation of Zcash \cite{zcash}, a
cryptocurrency using zk-SNARKs to ensure transaction privacy.

As early as December 2014, Vitalik Buterin, one of the founders of
Ethereum, explored solving this problem with secure multi party
computation (sMPC) \cite{secretSharingDaos}. In more recent writing,
Buterin shares that ``when [he] and others talk to companies about
building their applications on a blockchain, two primary issues always
come up: scalability and privacy'' \cite{privacyOnTheBlockchain}.

Scalability of public blockchains is a hurdle to mainstream adoption.
Some of the best minds in the cryptocurrency space \cite{lightning}
\cite{ethereumSharding} \cite{plasma} are working on multiple
order-of-magnitude improvements. Privacy, however, hasn't garnered the
same attention, especially in smart contracts.

Basic use cases of smart contracts, including publishing secrets after
certain criteria are met, assessing borrower risk for a loan, and
signing messages and transactions, are incredibly difficult on today's
public blockchains.

\section{Introducing keeps}

To solve this mismatch between the transparency of public blockchains,
and the need of many smart contracts for private data, we introduce
the idea of {\em keeps}.

A keep is an off-chain container for private data. Keeps allow
contracts to manage and use private data without exposing the data to
the public blockchain.

\subsection{Keep operations}

\begin{table*}[t]
  \centering
  \begin{tabular}{|rp{10cm}|}
  \hline
  \multicolumn{2}{|c|}{\textit{Keep operations}} \\
  \textbf{Create:} & $Contract_{owner}$ publishes a creation request,
  including an initial deposit and a public key,
  $K_{Contract_{owner}}$.\\
  \textbf{Accept:} & A keep, $Keep_{accepted}$, publishes one or more
  public keys $K_{Keep_{accepted_i}}$ signalling readiness.\\
  \textbf{Populate:} & $Contract_{owner}$ publishes an initial
  secret on-chain, encrypted in total or in shares by one or more
  $K_{Keep_{accepted_i}}$, or a specification for a secret to be
  generated.\\
  \textbf{Grant:} & $Contract_{owner}$ publishes another contract
  address, $Contract_{delegate}$, and a permission level, $P_{read}$
  or $P_{admin}$.\\
  \textbf{Compute:} & $Contract_{owner}$ or $Contract_{delegate}$
  publishes a function to compute over the secret, $F(S,...)$, as well
  as other arguments to $F$. Initially $F {\in}
  \{f_{identity},f_{rsa},f_{ecdsa}\}$, though additional functions are
  planned.\\
  \textbf{Results:} & $Keep_{accepted}$ publishes the results
  of its computation, either in whole or in part, over one or more
  invocations.\\
  \textbf{Shutdown:} & $Contract_{owner}$ or $Contract_{delegate}$
  with permission $P_{admin}$ publishes a shutdown request.\\
  \hline
\end{tabular}
\end{table*}

Though keeps maintain state off-chain, they are provisioned and
messaged by contracts on-chain. We will describe the keep in terms of
these on-chain operations. The practical implementation of keeps,
including security guarantees, will be covered later in the paper
\ref{eliminatingRisk} \ref{keepProviders}.

\subsubsection{Creation and population}

A contract, $Contract_{owner}$, requests a keep by publishing a
request to the blockchain. Once a keep, $Keep_{accepted}$, accepted a
request and is initialized off-chain, it will respond with a set of
public keys the calling contract can use to communicate privately with
the keep.

Once the keep has been created, it can be populated in a number of
ways. dApps can publish secret data to the blockchain, encrypted by
the keep's public keys, or send the data to the keep off-chain.
Alternatively, a keep can self-populate with pseudorandom data.

\subsubsection{Publishing data on-chain}

The purpose of a keep is to compute a function over its secret and
publish the results to the blockchain.

Initially, keeps will support publishing their secrets on-chain,
unmodified or encrypted with a public key provided by
$Contract_{owner}$. This enables functionality that's difficult in
today's public smart contracts, like a secret-exposing dead man
switch, useful in a variety of decentralized market schemes.

Keeps can be extended to use their secret in a variety of other ways,
including as key material for symmetric encryption and signing.

\subsubsection{Access management}

The owning contract $Contract_{owner}$ of a keep can delegate access
to the keep to other contracts.

Read and management access can each be granted, allowing another
contract i($Contract_{delegate}$) to request that a keep's content be
published (read permission, $P_{read}$), or to delegate further access
to other contracts (admin permission, $P_{admin}$). Owners
($Contract_{owner}$) can also revoke their own access.

Access management enables multi-party secret escrow and auditability
of secret access.

\subsubsection{Destruction}

Depending on the use case, keeps can be long- or short-lived.
Contracts can request that a keep shut down, and should also handle
keeps that are terminated unexpectedly, covered in more detail later
in the paper \ref{uptime}.

\section{Eliminating third-party risk} \label{eliminatingRisk}

We've described a simple black box for off-chain data storage. The
standardization of this method of secret management will enable
secrets to be bought, sold, and transferred on a public blockchain,
but doesn't inherently solve third-party risks.

Next, we'll describe techniques to elimnate third-party risk.

\subsection{Secure multi party computation}

Secure multi party computation (sMPC) is a type of cryptographic
system where a computation is distributed across multiple
participants, some of which may be dishonest. Each participant is
initially given access to a share of a secret by a dealer, and
computes a function over that share. The outputs are then reported to
the dealer, who can assemble the final output, without any participant
learning more than their initial secret share.

Intuitively, sMPC works like this.

\begin{enumerate}
  \item A dealer $D$ wants to compute a function $F$ over a secret,
      $S$.
  \item The dealer selects $n$ parties to the computation, sending
      each of them a share of the secret, $s_i$.
  \item Each party computes a function over their share $f_i(s_i)$ and
      reports the result to the dealer.
  \item The dealer combines these outputs, such that
      $G(f_1(s_1),f_2(s_2),...f_n(s_n)) = F(S)$
\end{enumerate}

The shares $s_i$ should be chosen in such a way that exposing any
share does not jeopardize the secret $S$. A common approach is to use
Shamir's secret sharing \cite{shamir}, such that details about the
secret remain confidential in the face of $n-1$ dishonest parties.

This explanation holds for all $F$ including addition, subtraction,
and multiplication by a known constant. To achieve general
computation, however, we also need to be able to multiply secrets
securely.

Multiplication adds what the literature calls ``rounds''- communication
between the parties, rather than just the dealer $D$.

To multiply two secrets, each party $P_i$ of the $n$ chosen by the
dealer splits its share, $s_i$, into two components, $s_{i1}$ and
$s_{i2}$. The party multiplies those two components, resulting in
$s_{i'}$. Each $P_i$ then acts as a dealer among the the remaining
parties, splitting $s_{i'}$ into $n-1$ pieces.

Each $P_i$ can now resolve their resulting share of the round of
multiplication, $s'_i$, given their access to $n-1$ shares of
$s_{i'}$.

With addition and multiplication, sMPC can securely execute general
computation, at the expense of communication overhead between the
computing parties.

\subsection{sMPC and the blockchain}

sMPC was originally conceived in 1982 \cite{yao1982protocols}, but its
practical application has been limited due to restrictions on the
security model. Existing sMPC solutions only maintain security in the
face of an honest majority of parties.

The advent of the blockchain enables secure usage of sMPC in
adversarial scenarioes. By using a public blockchain as an immutable
ledger, sMPC can be made secure in the face of a dishonest
supermajority \cite{spdz}, and with the requirement of a network
token, can be made strongly Sybil-resistant
\ref{incentivizingProviders}.

For these reasons, sMPC and blockchains are a natural fit. In the
smart contract space, sMPC has been proposed before as a privacy
mechanic.

In 2014, Vitalik Buterin gave a strong introduction to the subject in
an early blog post on privacy on the Ethereum public blockchain
\cite{secretSharingDaos}. In 2016, a team from UMD designed Hawk
\cite{hawk}, a system that marries public and private smart contracts
via sMPC, and the Enigma project out of MIT describes a system related
to ours \cite{enigma}, with a wider focus on general private
computation.

The Keep network will incorporate these ideas into the first
production-ready sMPC system for a public blockchain.

\section{Keep providers} \label{keepProviders}

The Keep network includes a number of different provider types, each
with their own strengths and tradeoffs. The most important provider,
however, is a novel application of secure multi party computation.

\subsection{Simple sMPC}

Simple sMPC keeps are backed by $n$ nodes, each of which maintain a
share of the provided secret, such that the secret can't be
reconstructed without all $n$ nodes colluding.

These keeps can be populated securely by divvying up a secret into
shares via Shamir secret sharing \cite{shamir}, and encrypting each
share with its respective node's public key. The encrypted shares can
then be published to the public blockchain, or communicated off-chain.

The only computation these keeps will run is an implementation of
distributed RSA \cite{mauland2009realizing} on sMPC, used to publish
encrypted data to the blockchain.

\subsection{Signing sMPC}

The next provider will extend the sMPC keep with two new operations-
securely generating pseudorandom numbers, and signing and encrypting
data, using the keep's contents as a key.

In addition to simple pseudorandom numbers, signing keeps will be able
to generate RSA \cite{mauland2009realizing} and Bitcoin
\cite{gennaro2016threshold,coinparty} key pairs, or be populated with
them via secret sharing.

This means signing keeps will be able to sign and secure contract
communications on- and off-chain, as well as sign transactions for
Bitcoin, Ethereum, and other cryptocurrencies.

Finally, signing keeps can act as pRNG oracles, significantly
improving current methods of random number generation on public
blockchains.

\subsection{Trusted third-party}

In the case where $n = 1$, sMPC keeps no longer provide
confidentiality guarantees. In that case, a keep node is acting as a
trusted third-party.

These keeps are suitable for lower-value applications and testing, and
will be significantly less expensive than more secure variants.

\subsection{Future providers}

The off-chain keep pattern is flexible enough to include a variety of
other pluggable providers, each with their own unique benefits.

\subsubsection{Secure hardware}

Keeps backed by secure hardware can be used to lower the cost of
securing private data by verifying that only signed code is run
against privileged data.

Instead of requiring $n$ nodes to safely split a secret, a secret can
be sent to a single node that's properly responded to a challenge,
proving it's running signed code. Not only are fewer nodes required,
but these keeps wouldn't suffer the computation overhead of secure
multi-party computation.

This sort of security is fundamentally weaker than that provided by
secure multi-party computation. If a single secure hardware
manufacturer is compromised, it puts all nodes using that hardware at
risk, shifting the threat model. The cost and benefit of this approach
will depend on the application.

\subsubsection{Private smart contracts}

Unlike related work on systems like Enigma \cite{enigma} or Hawk
\cite{hawk}, which use sMPC to build off-chain and alternative-chain
computation networks for private smart contracts, we've chosen to
restrict the initial sMPC keeps to generating, securing, storing,
encrypting, and transmitting secrets. Such restrictions help to
minimize the attack surface on keeps in a production network.

In later work, sMPC schemes can be used to build more feature-rich
keeps. These keeps will enable complex use cases, like operating
private ledgers against public blockchains, or running third-party
code trustlessly on private data.

\section{Incentivizing keep providers} \label{incentivizingProviders}

Providers need to be incentivized to maintain capacity on the network.
Running and securing keeps should be a profitable way to use excess
compute and storage resources.

Consumer contracts, on the other hand, need keeps that will

\begin{itemize}
  \item Be highly available and robust against data loss
  \item Maintain confidentiality and data integrity
\end{itemize}

\subsection{Paying for keeps}

The best payment structure for keep providers will reward highly
available keeps, and punish poor performance.

<sequence diagram of deposit + per-operation payment>

The two primary costs providers incur are storage and compute, which
map naturally to paying keeps per block and per operation.

Payment per block can be accomplished via a deposit to the managing
contract at the time of keep initialization, metered out over the
lifetime of the keep, and refilled occasionally by the calling
contract. Though this seems like a good fit for payment channels,
minimizing on-chain fees, the security ramifications differ from
typical two-party channels. These differences are discussed further in
the next section.

Payment per operation is simpler. Each request to publish a keep's
contents will require payment of an amount agreed to at the
initialization of a keep.

\subsection{Concerns with uptime and reliability} \label{uptime}

Because availability is vital to using keeps in practice, improper
termination must be disincentivized.

<proper shutdown protocol>

Any keep that doesn't respond properly within a certain block count
threshold to a request will be considered aborted. Aborted keeps will
forfeit all client deposits that have yet to be disbursed. To avoid
skewing client incentives, the deposits that have been earned, but not
yet disbursed, will be burned, and the unearned deposits will be
returned to the client.

Volatility in the crypto currency markets can provide a strong
incentive for a keep provider to improperly terminate a keep. If the
value of the paid currency drops significantly relative to the cost of
running a keep, it's in a provider's best interest to devote their
limited resources to a better-paying client.

To counter this issue, keep providers will need a protocol to
optionally re-negotiate fees for a running keep.

\subsection{Concerns with active attacks}

Existing open-source sMPC frameworks, such as VIFF \cite{viff}, are
secure against active attacks in the presence of a Â¾ supermajority of
honest nodes. In such an attack, keeps can be forced to return
malformed data, but secrets can't be compromised unless all nodes with
a unique share backing an sMPC keep are colluding- an extremely high
bar for a Sybil attack.

Recent approaches using SPDZ proofs \cite{spdz} anchored on the
blockchain \cite{bitcoinSmpc, blockchainMultipartyComputation} make
such correctness attacks impossible, even if all nodes backing a keep
are compromised. sMPC keeps will publish proofs to the public
blockchain that can be used to verify correctness. The threat of
active attacks is then reduced to disrupting keep availability, rather
than returning malformed data.

We address the issue of network disruption by introducing two
incentives to keep providers, making active attacks on data
availability impractically expensive.

First, keep providers will be required to prove their holdings in a
token native to the system. Significant disruption of the network
should lead to a drop in the value of the token, incentivizing
provider honesty, lest they devalue their holdings. This scheme also
provides resistance to Sybil attacks- an active attacker would need to
obtain an outsize portion of all tokens locked up by keep providers to
ensure their overwhelming selection backing new keeps.

Second, keep redundancy can be used to further minimize availability
disruptions \cite{blockchainMultipartyComputation}. All nodes can be
required to include a deposit when they publish their results. If
their results can't be verified by the included SPDZ proof, their
deposit is forfeit to competing nodes.

\section{High-level network design}

To bring these components together into a functional network,
initially built against the Ethereum blockchain, we'll introduce a few
more ideas.

\subsection{The keep market}

Different keep types will naturally incur different costs, and offer
differing guarantees and functionality to contract developers. At a
given time, the capacity available on the keep network will also be
limited capacity.. For this reason, a market will need to be developed
that matches keep providers to contracts based on bids for price per
block, price per operation, and required functionality.

\subsection{The Keep network token}

The native network token will be required for providers to participate
in the keep market. Requiring a native token, rather than the
underlying blockchain's currency, means providers will suffer from
negative externalities in the presence of malicious behavior.

Keep operations can be paid for with the native token, or with the
underlying blockchain's currency, based on the keep market.

\subsection{The result registry}

Keeps will offer a number of methods to publish to the public
blockchain. In the case where keeps publish to a smart contract
provided by the keep owner, coordination is simple. In uses that don't
have a natural contract to communicate with, a result registry will be
provided as a default to simplify keep and owner coordination.

\section{Applications}

\subsection{Dead man switch}

A dead man switch is a device that is automatically activated in case
its owner becomes incapacitated. Keeps enable a particular kind of
dead man switch- publishing a secret, under certain contract
conditions.

Examples of dead man switch applications with keeps include automated
inheritance (``send my beneficiary my private key if I don't check in
quarterly''), arbitration with time limits (``if no decision is made in
10 blocks, publish a shared secret''), as well as protection for
leakers (``publish a key to these insurance files if I don't check
in'').

\subsection{Marketplaces for digital goods}

Buying and selling digital goods on public blockchains today requires
settling off-chain. Keeps make marketplaces for digital goods, like
audio and video files, straightforward.

Without keeps, each transfer of a private digital good requires one or
more hash-reveal constructions on-chain. More complex scenarioes
that require escrow, arbitrators, and other parties who might need
access to the transfered digital good will need ${n^2}$ on-chain
transactions to maintain security. They also require each party to be
online to participate.

Keeps obviate always-online requirements, and simplify the hash-reveal
protocol to access management. All keep access is auditable, and
participants can have access to a keep without viewing its contents,
allowing further optimization.

Without an always-online requirement or complex reveal protocols,
keeps can efficiently support services like iTunes on the blockchain.

\subsection{Pseudorandomness oracle}

Since keeps can populate themselves with random data, they can act as
pseudorandomness oracles, improving on currently popular methods
\cite{prngStackexchange}. sMPC and other secure keeps are a good fit for
decentralized lotteries and other games of chance, as well as offering
a building block for other on-chain algorithms that require
tamper-resistant pRNG.

This capability is an important component of advanced keep users, like
decentralized signing.

\subsection{Decentralized signing service}

Signing sMPC keep providers are able to sign messages, including
blockchain transactions, using a generated or provided private key.

For the first time, contracts will be able to assert their identity
off-chain, without requiring the recipient's awareness of blockchain
state.

Consider a decentralized signing service for Bitcoin transactions. The
service can participate in multi-signature transactions, only signing
transactions that follow a strict set of rules, including daily
spending limits and recipient whitelists.

Other uses for such a service include second-factor authentication,
where a contract can answer a challenge-response protocol based on
rules on the blockchain.

\subsection{Custodial wallets and cross-chain trading}

As a special case of a signing service, contracts can use keeps to
generate their own cryptocurrency wallets, taking full custody of any
received funds.

For example, a contract can generate a Bitcoin wallet, and sign
Bitcoin transactions in response to receiving assets on the contract's
native blockchain.

\subsection{Encryption service for blockchain storage}

Services like Filecoin \cite{filecoin} and Storj \cite{storj} are
being built to provide cheap, ubiquitous storage, accessible globally,
via smart contracts and traditional storage interfaces.

These services offer few privacy guarantees by default, leaving the
onus of file encryption on users. Keeps can provide a private bridge
to blockchain storage. By generating an AES key at keep initialization
and providing off-chain data access to the keep, smart contracts can
use keeps to secure files stored on decentralized services.

\subsection{Banking on public blockchains}

As more keep providers are developed, more applications that once
required a private blockchain can be built against public networks.

Traditional finance offers many examples. Consider lending, a basic
service provided by most banks.

There are a number of sensitive variables involved in the lending
process. Borrower credit scores are sensitive; risk assessment is
highly competitive; the terms of a loan aren't typically made public.

Keep providers that execute generic private smart contracts can
protect scores and the risk assessment process, while maintaining
auditability and all other benefits of a public blockchain.

\bibliographystyle{unsrt}
\bibliography{references}{}

\end{document}
